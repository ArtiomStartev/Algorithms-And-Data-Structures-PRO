# Лабораторная работа №2: Анализ алгоритмов связанных списков

## Введение
В рамках лабораторной работы были реализованы два основных алгоритма структур данных:

- **Односвязный список (Singly Linked List)** — узлы связаны указателем на следующий элемент.
- **Двусвязный список (Doubly Linked List)** — узлы имеют указатели на предыдущий и следующий элементы.

Работа включает:
- Описание методов и их временную сложность.
- Преимущества и недостатки каждой структуры.
- Оптимальные сценарии применения.

---

## Реализация алгоритмов

### 1. Односвязный список
#### Методы:
- **Insert:** Вставляет новый узел в конец списка.  
  _Time Complexity:_ `O(1)`
- **InsertAfter:** Вставляет узел после указанного.  
  _Time Complexity:_ `O(1)`
- **Find:** Поиск узла с заданным значением.  
  _Time Complexity:_ `O(n)`
- **Remove:** Удаляет узел с указанным значением.  
  _Time Complexity:_ `O(n)`
- **RemoveAfter:** Удаляет узел, следующий за указанным.  
  _Time Complexity:_ `O(1)`
- **AssertNoCycles:** Проверяет наличие циклов в списке.  
  _Time Complexity:_ `O(n)`

#### Преимущества:
- Простая реализация.
- Экономия памяти (отсутствует указатель на предыдущий элемент).
- Быстрая вставка в конец при наличии указателя `Tail`.
- Эффективное добавление и удаление элементов за константное время.
- Динамическое управление размером списка.

#### Недостатки:
- Невозможность быстрого доступа к предыдущему элементу.

#### Оптимальные сценарии применения:
- Однократный проход по данным.
- Реализация очередей или структур с порядковым доступом (FIFO).

---

### 2. Двусвязный список
#### Методы:
- **Insert:** Вставляет новый узел в конец списка.  
  _Time Complexity:_ `O(1)`
- **InsertBefore:** Вставляет узел перед указанным.  
  _Time Complexity:_ `O(1)`
- **InsertAfter:** Вставляет узел после указанного.  
  _Time Complexity:_ `O(1)`
- **Find:** Поиск узла с заданным значением.  
  _Time Complexity:_ `O(n)`
- **Remove:** Удаляет указанный узел.  
  _Time Complexity:_ `O(1)`
- **AssertNoCycles:** Проверяет наличие циклов в списке.  
  _Time Complexity:_ `O(n)`

#### Преимущества:
- Возможность обхода в обоих направлениях.
- Минимальные изменения указателей при вставке или удалении узлов.
- Удобен для реализации двусторонних очередей (deque).

#### Недостатки:
- Больший расход памяти из-за хранения двух указателей.
- Более сложная реализация по сравнению с односвязным списком.

#### Оптимальные сценарии применения:
- Двусторонняя навигация по данным.
- Реализация структур, где важен быстрый доступ к следующему и предыдущему элементам (например, LRU-кэш).

---

## Выводы
1. **Односвязные списки**:
    - Эффективны для задач с линейным проходом по данным.
    - Обладают ограниченной функциональностью из-за отсутствия обратной ссылки.

2. **Двусвязные списки**:
    - Обеспечивают гибкую навигацию по данным.
    - Удобны для сложных операций, таких как удаление или вставка в произвольное место, но требуют большего объема памяти.

### Итог:
- Выбор структуры данных зависит от требований задачи.
    - **Односвязные списки** подходят для упрощенного хранения и последовательного доступа.
    - **Двусвязные списки** подходят для сложных сценариев, требующих двустороннего доступа.

### Тестирование:
Все реализованные методы успешно прошли тесты, подтвердив их корректность. Оба списка продемонстрировали стабильную работу без ошибок и утечек памяти.
