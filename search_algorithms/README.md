# Лабораторная работа №1: Анализ алгоритмов поиска

В данной лабораторной работе были реализованы и протестированы четыре алгоритма поиска:
- Линейный поиск (Linear Search)
- Бинарный поиск (Binary Search)
- Экспоненциальный поиск (Exponential Search)
- Бинарное дерево поиска (Binary Search Tree)

Цель анализа: оценка производительности каждого алгоритма в зависимости от размера массива и порядка элементов, сравнение практической сложности с теоретической и определение оптимальных сценариев применения.

## 1. Зависимость времени выполнения от количества и порядка элементов

### 1.1 Линейный поиск (Linear Search)
**Описание:** Последовательно сравнивает каждый элемент массива с целевым значением до нахождения совпадения или достижения конца массива.

**Теоретическая сложность:**
- Лучший случай: `O(1)` (элемент найден на первом месте)
- Средний и худший случай: `O(n)` (пробегается по всему массиву)

**Анализ результатов:**

| Размер массива | Порядок      | Среднее время (нс) |
|----------------|--------------|--------------------|
| 1000           | Ascending    | 238                |
| 1000           | Descending   | 326                |
| 1000           | Random       | 161                |
| 10,000         | Ascending    | 2,390              |
| 10,000         | Descending   | 1,494              |
| 10,000         | Random       | 2,222              |
| 50,000         | Ascending    | 7,742              |
| 50,000         | Descending   | 8,397              |
| 50,000         | Random       | 988                |
| 1,000,000      | Ascending    | 2,371              |
| 1,000,000      | Descending   | 8,411              |
| 1,000,000      | Random       | 15,682             |

**Выводы:**
- Время выполнения линейного поиска увеличивается линейно с ростом размера массива.

### 1.2 Бинарный поиск (Binary Search)
**Описание:** Работает только на отсортированных массивах. Делит массив пополам, сравнивая средний элемент с целевым значением.

**Теоретическая сложность:** `O(log n)`

**Анализ результатов:**

| Размер массива | Порядок      | Среднее время (нс) |
|----------------|--------------|---------------------|
| 1000           | Ascending    | 114                |
| 10,000         | Ascending    | 170                |
| 50,000         | Ascending    | 194                |
| 1,000,000      | Ascending    | 221                |

**Выводы:**
- Время выполнения бинарного поиска растет логарифмически с увеличением размера массива, что соответствует теоретической сложности O(log n).
- Алгоритм стабильно работает для больших массивов, демонстрируя минимальные затраты времени по сравнению с линейным поиском.

### 1.3 Экспоненциальный поиск (Exponential Search)
**Описание:** Находит диапазон, в котором может находиться целевой элемент, экспоненциально увеличивая индекс, а затем выполняет бинарный поиск в найденном диапазоне.

**Теоретическая сложность:** `O(log n)`

**Анализ результатов:**

| Размер массива | Порядок      | Среднее время (нс) |
|----------------|--------------|---------------------|
| 1000           | Ascending    | 121                |
| 10,000         | Ascending    | 173                |
| 50,000         | Ascending    | 190                |
| 1,000,000      | Ascending    | 257                |

**Выводы:**
- Время выполнения экспоненциального поиска также растет логарифмически, подтверждая теоретическую сложность O(log n).
- Производительность близка к бинарному поиску, что ожидаемо, так как оба алгоритма основаны на логарифмическом делении массива.

### 1.4 Поиск в бинарном дереве поиска (Binary Search Tree)
**Описание:** Поиск в бинарном дереве начинается с корня и рекурсивно идет в левое или правое поддерево в зависимости от текущего узла.

**Теоретическая сложность:**
- Сбалансированное дерево: `O(log n)`
- Несбалансированное дерево: `O(n)`

**Анализ результатов:**

| Размер массива | Порядок      | Среднее время (нс) |
|----------------|--------------|---------------------|
| 1000           | Ascending    | 1,962              |
| 1000           | Descending   | 1,385              |
| 1000           | Random       | 81                 |
| 10,000         | Ascending    | 27,756             |
| 10,000         | Descending   | 19,828             |
| 10,000         | Random       | 123                |
| 50,000         | Ascending    | 48,257             |
| 50,000         | Descending   | 25,946             |
| 50,000         | Random       | 269                |
| 1,000,000      | Ascending    | 54,464             |
| 1,000,000      | Descending   | 40,690             |
| 1,000,000      | Random       | 219                |

**Выводы:**
- Для отсортированных (ascending) массивов время выполнения BST поиска значительно выше, чем у бинарного и экспоненциального поиска, что указывает на сильную несбалансированность дерева (линейная структура).
- Для descending порядка время выполнения BST поиска также высокое, хотя немного ниже, чем для ascending. Это также свидетельствует о несбалансированности дерева.
- Для random порядка время выполнения значительно ниже, что предполагает более сбалансированное дерево, обеспечивая производительность ближе к O(log n).
- Порядок элементов существенно влияет на производительность BST поиска из-за структуры дерева: отсортированные данные приводят к линейной структуре дерева, ухудшая производительность до O(n).

## 2. Сравнение теоретической и практической сложности
### **2.1 Линейный поиск:**
- Теоретическая сложность: O(n)
- Практическая сложность: Соответствует ожиданиям; время выполнения линейно увеличивается с размером массива.
- Вывод: Линейный поиск показывает линейный рост времени выполнения, что подтверждает теоретическую сложность O(n).

### **2.2 Бинарный поиск:**
- Теоретическая сложность: O(log n)
- Практическая сложность: Время выполнения увеличивается медленно даже для больших массивов, демонстрируя логарифмическую зависимость.
- Вывод: Практические результаты подтверждают теоретическую сложность бинарного поиска O(log n).

### **2.3 Экспоненциальный поиск:**
- Теоретическая сложность: O(log n)
- Практическая сложность: Время выполнения также растет логарифмически, схоже с бинарным поиском.
- Вывод: Экспоненциальный поиск подтверждает теоретическую сложность O(log n), демонстрируя сопоставимую производительность с бинарным поиском.

### **2.4 Бинарное дерево поиска:**
- Теоретическая сложность:
    - Сбалансированное дерево: O(log n)
    - Несбалансированное дерево: O(n)
- Практическая сложность:
    - Для отсортированных массивов и больших размеров: Время выполнения растет линейно, что указывает на O(n) сложность из-за несбалансированной структуры дерева.
    - Для случайных массивов: Время выполнения значительно ниже, приближаясь к логарифмической сложности.
- Вывод: Практическая сложность BST поиска соответствует теоретической. В зависимости от порядка вставки данных структура дерева может быть сбалансированной (O(log n)) или несбалансированной (O(n)).

## 3. Сравнение алгоритмов и их применение
### **3.1. Линейный поиск**
**Преимущества:**
  - Простота реализации.
  - Работает на любых массивах (отсортированных и неотсортированных).
  - Эффективен для небольших массивов.

**Недостатки:**
  - Медленная производительность на больших массивах.

**Оптимальные сценарии применения:**
  - Когда массив не отсортирован и его сортировка затратна.
  - Для небольших наборов данных, где разница в производительности несущественна.
  - Когда нужно найти все вхождения элемента, а не только первое.

### **3.2. Бинарный поиск**
**Преимущества:**
    - Высокая производительность на больших отсортированных массивах.
    - Логарифмическая сложность обеспечивает быстрое выполнение.

**Недостатки:**
  - Требует предварительной сортировки массива.
  - Не подходит для динамически изменяющихся массивов без дополнительных структур данных.

**Оптимальные сценарии применения:**
  - Для больших массивов, которые уже отсортированы.
  - Когда требуется частый поиск в статическом массиве.
  - В случаях, когда производительность поиска критична.

### **3.3. Экспоненциальный поиск**
**Преимущества:**
  - Быстрый поиск в отсортированных массивах, особенно если целевой элемент находится ближе к началу.
  - Комбинирует преимущества линейного и бинарного поиска.

**Недостатки:**
  - Сложнее в реализации по сравнению с бинарным поиском.
  - Требует отсортированного массива.

**Оптимальные сценарии применения:**
- В случаях, когда целевые элементы часто находятся в первых частях массива.
- Для больших массивов, где бинарный поиск может быть не столь эффективен из-за распределения целевых элементов.

### **3.4. Бинарное дерево поиска (BST Search)**
**Преимущества:**
  - Позволяет эффективно выполнять вставку, удаление и поиск.
  - Логарифмическая сложность на сбалансированных деревьях.
  - Динамическая структура данных, подходящая для изменяющихся наборов данных.

**Недостатки:**
  - Производительность сильно зависит от балансировки дерева.
  - Без балансировки может деградировать до линейной сложности.
  - Требует дополнительной памяти для хранения структуры дерева.

**Оптимальные сценарии применения:**
  - Когда набор данных часто изменяется (добавление и удаление элементов).
  - Для структур данных, требующих быстрой вставки и удаления вместе с поиском.
  - В случаях, когда важна гибкость структуры данных.

## 4. Заключение
На основе полученных результатов и анализа можно сделать следующие выводы:

  1. **Линейный поиск** является простым и универсальным, но его производительность существенно ухудшается с ростом размера массива. Подходит для небольших массивов или когда данные не отсортированы.

  2. **Бинарный поиск** демонстрирует отличную производительность на больших отсортированных массивах, подтверждая свою теоретическую эффективность. Идеально подходит для статических массивов, где требуется частый поиск.

  3. **Экспоненциальный поиск** показывает сопоставимую с бинарным поиском производительность, но может быть предпочтителен в случаях, когда целевые элементы часто располагаются ближе к началу массива.

  4. **Бинарное дерево поиска** предоставляет гибкость в динамических наборах данных, но его эффективность сильно зависит от балансировки дерева. Для отсортированных или случайных данных без балансировки производительность может быть хуже по сравнению с бинарным поиском.

Каждый из рассмотренных алгоритмов поиска обладает своими преимуществами и недостатками, которые определяют его применение в различных сценариях.
Понимание теоретических и практических аспектов их производительности позволяет выбирать наиболее подходящий алгоритм для конкретных задач, обеспечивая эффективную работу программных решений.


